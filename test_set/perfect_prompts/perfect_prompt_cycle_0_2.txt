You’ve got a single 2-way cycle:

* `messaging.py` → imports `PooledConnection`, `is_connection`, `maybe_channel` from `connection.py`
* `connection.py` → (even though locals) imports `messaging.py` in `Connection.Producer/Consumer` (and friends)

Because your ATD treats **any** reference as a dependency (including local/dynamic/type-only), this is a hard cycle.

Below is a refactor that breaks the cycle **without adding any new ones**. The key idea is to remove `messaging` → `connection` entirely via **duck typing + a tiny marker attribute**, so only `connection` depends on `messaging` (1-way).

---

# 1) Add a marker to `Connection`

Add a simple sentinel on the class. This lets `messaging` recognize “a kombu connection” **without importing** the class.

```python
# connection.py

class Connection:
    # ...
    __kombu_connection__ = True
    # ...
```

(Anything that *behaves* like a Connection can opt-in by defining this attribute if you ever need that.)

---

# 2) Stop importing `connection` from `messaging`

Delete this line at the top of `messaging.py`:

```python
from .connection import PooledConnection, is_connection, maybe_channel
```

Replace it with two tiny local helpers that use duck typing:

```python
# messaging.py

def _looks_like_connection(obj) -> bool:
    # Fast path: official marker
    if getattr(obj, "__kombu_connection__", False):
        return True
    # Fallback: duck-typing for older/third-party wrappers
    return hasattr(obj, "default_channel") and hasattr(obj, "transport")

def _maybe_channel(ch):
    return ch.default_channel if _looks_like_connection(ch) else ch
```

Now update the few call sites:

* In `Producer.revive`:

```python
def revive(self, channel):
    if _looks_like_connection(channel):
        connection = channel
        self.__connection__ = connection
        channel = ChannelPromise(lambda: connection.default_channel)
    # rest unchanged…
```

* In `Consumer.revive`:

```python
def revive(self, channel):
    self._active_tags.clear()
    channel = self.channel = _maybe_channel(channel)
    # rest unchanged…
```

* In `Producer.__exit__`, remove the `isinstance(..., PooledConnection)` check (which forces an import) and switch to a safe duck-typed check:

```python
def __exit__(self, exc_type, exc_val, exc_tb) -> None:
    if self.__connection__ is not None and exc_type is not None:
        pool = getattr(self.__connection__, "_pool", None)
        if pool is not None and hasattr(pool, "replace"):
            pool.replace(self.__connection__)
    self.release()
```

That’s it for `messaging.py`.

---

# 3) (Optional) Keep public helpers for others

`connection.py` currently exports `maybe_channel` and `is_connection`. You can keep them for public API stability—they no longer participate in a cycle because `messaging` doesn’t import them.

If you want symmetry, you could even re-implement them in terms of the same rules:

```python
# connection.py

def is_connection(obj: Any) -> bool:
    return getattr(obj, "__kombu_connection__", False)

def maybe_channel(channel):
    return channel.default_channel if is_connection(channel) else channel
```

(Keeping the signatures preserves downstream users.)

---

# 4) Why this breaks the cycle (and doesn’t add new ones)

* After the change:

  * `connection.py` → `messaging.py` (factory methods). **One-way only.**
  * `messaging.py` → **no reference** to `connection.py`. (It uses local helpers + attribute checks.)
* No new modules introduced, so there’s nowhere for a new cycle to hide.
* Type-only imports avoided; you’re not importing `Connection` or `PooledConnection` anywhere in `messaging.py`.

---

# 5) Behavior & safety notes

* The `_looks_like_connection` check prefers the explicit `__kombu_connection__` marker, then falls back to conservative duck typing (`default_channel` + `transport`). This mirrors how `maybe_channel` was used and is very low risk: Channels won’t have `default_channel`.
* The `PooledConnection` handling in `Producer.__exit__` remains correct: we only “replace” if a `_pool` with a `replace` method is present. That’s exactly what the original `isinstance(..., PooledConnection)` implied, but now it’s decoupled.
* Public surface area and docstrings don’t need to change; the factories (`Connection.Producer`, `Connection.Consumer`) remain as-is (still a single dependency edge from `connection` → `messaging`).

---

## Minimal patch summary

**connection.py**

* Add `__kombu_connection__ = True` on `Connection`.
* (Optionally) re-implement `is_connection`/`maybe_channel` using the marker.

**messaging.py**

* Remove: `from .connection import PooledConnection, is_connection, maybe_channel`
* Add `_looks_like_connection` and `_maybe_channel` helpers.
* Replace the three call sites as shown.

This cleanly removes the cycle while keeping the architecture flat and without introducing any new dependencies.
