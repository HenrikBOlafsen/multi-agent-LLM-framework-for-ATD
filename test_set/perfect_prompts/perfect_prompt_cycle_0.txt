Goal
Break the architectural cycle between `kombu/connection.py` and `kombu/messaging.py` without changing behavior or public API.

Important
Please refactor to break this cycle, without increasing architectural technical debt elsewhere (e.g., no new cycles). Feel free to add a small new file if needed.
My ATD metric treats ANY module reference as a dependency (dynamic/lazy/type-only all count). So making imports lazy is NOT sufficient. I care about architecture (static coupling), not runtime import order. Functionality must not change.

Why this exists (short)
`messaging.py` pulls tiny helpers from `connection.py`, while `connection.py` references `messaging.py` in its factories. That creates a bidirectional edge in the static graph.

Technique (describe what to do, not exact code)
1) Extract the tiny “channel/connection shape” helpers (e.g., `is_connection`, `maybe_channel`) into a new **private, dependency-free** module (e.g., `kombu/_channel_helpers.py`). This file must NOT import from `kombu.*` (not even under TYPE_CHECKING). Use structural/duck typing (check for attributes like `default_channel`) instead of importing types.
2) Update `messaging.py` to import those helpers from the new module. Remove any import from `connection.py` (including `PooledConnection`).
   - Where needed (e.g., in `Producer.__exit__`), replace nominal checks like `isinstance(..., PooledConnection)` with a safe duck-typed check (e.g., look for `_pool` and call `replace` if present).
3) Preserve public API by re-exporting the helper names from `connection.py` so existing imports still work:
   `from kombu.connection import is_connection, maybe_channel`
4) Do NOT change the `Connection.Producer/Consumer` factory methods; their dynamic imports can stay. Once `messaging.py` stops importing from `connection.py`, the static cycle goes away.

Scope & guardrails
- Keep the diff minimal: primarily touch `connection.py`, `messaging.py`, and add one small helper module.
- No new third-party deps. No broad formatting changes. No function signature changes.
- Do not “move” the cycle to another module; the helper module must not import from `kombu.*`.

Done when
- `messaging.py` has no imports from `connection.py`.
- The new helper module exists and has zero `kombu.*` imports.
- `connection.py` re-exports the helper names (public imports still work).
- `Connection.Producer()` and `Connection.Consumer()` still construct and behave the same.
- The static dependency graph shows no cycle between `connection.py` and `messaging.py`, and no new cycles were introduced.
