Goal
Break the dependency cycle by removing exactly one static edge, using architectural refactoring that preserves behavior and public API.

Important (exact text:) "My ATD metric treats ANY module reference as a dependency (dynamic/lazy/type-only all count). So making imports dynamic or lazy is NOT sufficient. I care about architecture (static coupling), not runtime import order."

Why this exists (short)
The cycle involves: `werkzeug/datastructures/range.py` → `werkzeug/datastructures/__init__.py` → `werkzeug/urls.py` → `werkzeug/serving.py` → `werkzeug/__init__.py` → `werkzeug/datastructures/range.py`. The key dependency is that `range.py` indirectly depends on `__init__.py` through its import of `http`, which is part of the same package and likely re-exports symbols from `__init__.py`.

Technique
Remove the transitive dependency from `range.py` to `__init__.py` by extracting the minimal functionality it needs into a private helper module. Since `range.py` imports `http` via `from .. import http`, and `http` likely re-exports or imports from `__init__.py`, we'll move the small amount of code that `range.py` actually needs from `http` into a new private helper module. This helper module will have zero imports from the project (including under TYPE_CHECKING) and will be re-exported from `http.py` to maintain the public API. Then, `range.py` will import directly from this new helper instead of going through `http`.

Post-change Import Simulation
ModuleA imports: `from .. import http` → `from ._range_helpers import RangeHeaderParser`
ModuleB imports: `from . import http` → `from ._range_helpers import RangeHeaderParser`

Scope & guardrails
- Only extract the minimal necessary code from `http.py` that `range.py` actually uses
- Create a truly dependency-free helper module with no project imports
- Re-export the extracted functionality from `http.py` to preserve public API
- Ensure no new cycles are introduced
- Maintain identical behavior and public API surface