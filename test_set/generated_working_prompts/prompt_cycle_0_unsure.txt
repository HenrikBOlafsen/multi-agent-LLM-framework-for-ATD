Goal
Break the dependency cycle between `kombu/connection.py` and `kombu/messaging.py` by removing exactly one edge, using a minimal architectural change that preserves behavior and public APIs.

Important
My ATD metric treats ANY module reference as a dependency (dynamic/lazy/type-only all count). So making imports lazy is NOT sufficient. I care about architecture (static coupling), not runtime import order.

Why this exists (short)
The two files have a mutual dependency: `connection.py` uses `Producer` and `Consumer` from `messaging.py` via dynamic imports inside methods, and `messaging.py` imports `PooledConnection`, `is_connection`, and `maybe_channel` from `connection.py` at the module level. This creates a static architectural cycle that needs to be broken by cutting exactly one edge.

Technique
To break the cycle, we will apply the following refactoring technique:

1. **Identify the stronger dependency**: Between the two edges, the top-level import in `messaging.py` to `connection.py` is more architecturally significant than the dynamic imports in `connection.py` to `messaging.py`. Cutting the top-level import from `messaging.py` to `connection.py` is preferred per ATD rules.

2. **Extract shared logic into a new helper file**: Create a small, neutral utility file (e.g., `kombu/utils/connection_helpers.py`) that contains only the three symbols currently imported from `connection.py` in `messaging.py`: `PooledConnection`, `is_connection`, and `maybe_channel`.    

3. **Move the symbols to the new helper file**: Move the definitions of `PooledConnection`, `is_connection`, and `maybe_channel` from `kombu/connection.py` to the new helper file. Ensure no other code from `connection.py` is moved.

4. **Update imports in `messaging.py`**: Change the import statement in `messaging.py` from `from .connection import PooledConnection, is_connection, maybe_channel` to `from .utils.connection_helpers import PooledConnection, is_connection, maybe_channel`.

5. **Update imports in `connection.py`**: Remove the import of `PooledConnection`, `is_connection`, and `maybe_channel` from `connection.py` since they are now in the new helper file.

6. **Ensure duck typing where appropriate**: Since the new helper file is meant to be neutral and not depend on either original file, use structural typing or duck typing checks instead of strict type checking if needed to avoid introducing new dependencies.

7. **Verify no new cycles are introduced**: Confirm that after the change, there are no new dependency cycles created in the system.

Scope & guardrails
- Only move the specific symbols (`PooledConnection`, `is_connection`, `maybe_channel`) and their associated logic to the new helper file.
- Do not move any behavior-bearing classes or introduce interfaces/ABCs.
- Do not alter public APIs or behaviors.
- The new helper file must import nothing from the rest of the repository.
- All existing usage patterns must remain unchanged.
- This is a rough guide; ensure correctness across the entire codebase post-refactor.

Done when
The dependency cycle is broken by removing exactly one edge: the top-level import from `kombu/messaging.py` to `kombu/connection.py`. The dynamic imports in `kombu/connection.py` to `kombu/messaging.py` remain intact, preserving functionality. No new cycles are introduced, and all public APIs stay unchanged.