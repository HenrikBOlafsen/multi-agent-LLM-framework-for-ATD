# dependency_expert_B.py

from agent_setup import AgentBase
from agent_util import clip

DEPENDENCY_EXPERT_B_SYSTEM = """You are a Dependency_Expert looking only at file B for an A->B edge.
Your job:
Explain precisely what parts of B that A depends on. You are given a summary of how A depends on B, and your role is to look at the code of file B and find the relevant parts of code for this dependency.
Quote relevant code (with line numbers) and explain, but do not include all code, only relevant code for the dependency A->B. And shorten code by making abstractions of it, like e.g. providing pseudo code instead or simply writing about it in plain text.
My ATD metric treats ANY module reference as a dependency (dynamic/lazy/type-only all count). I care about architecture (static coupling), not runtime import order.
Include flags: Top-level import: yes/no Â· Inside function: yes/no.
Rules:
- Stay factual. if unsure, say so.
- Your output should be human-readable and well explained, not JSON.
"""

class DependencyExpertB(AgentBase):
    def __init__(self, name: str, client):
        super().__init__(name, client, DEPENDENCY_EXPERT_B_SYSTEM)

    def summarize_dependency(self, file_path_A: str, file_path_B: str, file_B_text: str, dependency_summary_A: str) -> str:
        self.reset()
        user = f"""File A: {file_path_A}. File B {file_path_B}.

Please summarize the parts of file B that file A depends on, for later use by other agents. Only caring about static coupling.

Here is the summary of how file A depends on file B, generated by another agent:

=== BEGIN SUMMARY ===
{dependency_summary_A}
=== END SUMMARY ===

Here is file B:

=== BEGIN FILE ===
{clip(file_B_text)}
=== END FILE ===

"""
        return self.ask(user)

    def answer_question(self, file_path: str, file_text: str, question: str) -> str:
        # For follow-ups, include the file again (24B context). Keep it light; model should quote minimally.
        self.reset()
        user = f"""File: {file_path}

Question: {question}

Answer with minimal code quotes and line numbers + one-sentence context per quote.

=== BEGIN FILE ===
{clip(file_text)}
=== END FILE ===
"""
        return self.ask(user)