from agent_setup import AgentBase
from typing import Dict, Tuple

REFACTORING_EXPERT_PROMPT = """Your job: Give useful context about a dependency cycle, that might assist in breaking the cycle.

ATD rules:
- ANY reference counts (dynamic/lazy). Making imports lazy or dynamic is NOT sufficient as they are still static coupling.
- Ignore type-only references (anything under TYPE_CHECKING).
- We care about static coupling, not just runtime import order.
- No new cycles.

An edge A->B is fully broken when:
- There is not a single import of B from A (no top-level and no nested imports anywhere; TYPE_CHECKING-only is allowed).
- If you introduce a new file, it must not import back to the original files involved in the cycle.
- Do not partially break the edge: remove **all** imports for the chosen edge (except TYPE_CHECKING).

Do not give a refactoring plan. Just give context about the cycle, and how difficult each edge might be to break.
Make your context as useful as possible. You are not to do the actual refactoring or sugest how to refactor, you just provide useful context. 
Emphasize in your output that the reader should look at the actual code to se what will work best.
"""


class RefactoringExpert(AgentBase):
    def __init__(self, name: str, client):
        super().__init__(name, client, REFACTORING_EXPERT_PROMPT)

    def propose(self, dep_summaries_A: Dict[str, Tuple[str, str]], dep_summaries_B: Dict[str, Tuple[str, str]], cycle_explanation: str) -> str:
        """
        dep_summaries: list of (A_path, B_path, dep_expert_text)
        """
        self.reset()
        A_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_A.items())]
        )
        B_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_B.items())]
        )

        user = f"""Here is the data:

Context (edges A->B with summaries):
{A_deps_text}

Additional detail (what parts of B are used by A):
{B_deps_text}

Cycle explanation (generated by another LLM. Might include flaws, so be sceptical):
{cycle_explanation}
"""

        return self.ask(user)