from agent_setup import AgentBase
from typing import Dict, Tuple

REFACTORING_EXPERT_PROMPT = """You are a Refactoring Expert for a dependency cycle.
Your job: propose an ARCHITECTURAL change that breaks the cycle without changing behavior or public API.

ATD rules:
- ANY reference counts (dynamic/lazy). Making imports lazy or dynamic is NOT sufficient as they are still static coupling.
- Ignore type-only references (anything under TYPE_CHECKING).
- We care about static coupling, not just runtime import order.
- No new cycles.

Single-edge rule:
- Break the cycle by removing EXACTLY ONE static edge. Choose the edge that is the easiest/safest to break while still being a good refactor.

How to verify the chosen edge A->B is fully broken:
- There is not a single import of B from A (no top-level and no nested imports anywhere; TYPE_CHECKING-only is allowed).
- If you introduce a new file, it must not import back to the original files involved in the cycle.
- Do not partially break the edge: remove **all** imports for the chosen edge (except TYPE_CHECKING).

Refactoring techniques catalog (for inspiration; you may mix them or use other techniques):
- Extract tiny cross-imported helpers into a private, dependency-free helper module (helpers should avoid importing the project; prefer duck typing). Re-export as needed to keep public imports working.
- Move a lightweight symbol (function/constant/tiny utility) to the side that naturally owns it; preserve public API via re-export.
- Dependency inversion via a provider function/parameter so the consumer stops importing the provider.
- Introduce a minimal local protocol/ABC only if it adds no new import edges (prefer duck typing).
- Split a mixed-responsibility module into a dependency-free core plus features.
- Replace nominal cross-checks (isinstance against B.Class) with duck-typed predicates so the nominal import can be dropped.
- Replace a direct import with a callback/event hook registered from the outside (composition root).
- Import directly from a leaf instead of through a façade (__init__).

Please refactor to break this cycle, without increasing architectural technical debt elsewhere (e.g., no new cycles). My ATD metric treats ANY module reference as a dependency (dynamic/lazy all count). So making imports dynamic or lazy is NOT sufficient. I care about architecture (static coupling), not just runtime import order.

STRICT EMISSION RULES:
- Output **only** the following two sections, in this exact order, bounded by the sentinels:
<<<BEGIN_REFACTORING_PROMPT>>>
Cycle (concise)
Technique
<<<END_REFACTORING_PROMPT>>>
- “Cycle (concise)” = 3-6 sentences that clearly name the specific static edge you will remove (A→B), why that edge exists, and why removing it is lowest-risk and breaks the cycle without new ones.
- “Technique” = Do not give too detailed of a plan. No step by step list. But do give some loose directions of possible approaches and what you reccomend.
- Make sure both sections are inside <<<BEGIN_REFACTORING_PROMPT>>> <<<END_REFACTORING_PROMPT>>>.
"""


class RefactoringExpert(AgentBase):
    def __init__(self, name: str, client):
        super().__init__(name, client, REFACTORING_EXPERT_PROMPT)

    def propose(self, dep_summaries_A: Dict[str, Tuple[str, str]], dep_summaries_B: Dict[str, Tuple[str, str]], cycle_explanation: str) -> str:
        """
        dep_summaries: list of (A_path, B_path, dep_expert_text)
        """
        self.reset()
        A_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_A.items())]
        )
        B_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_B.items())]
        )

        user = f"""Here is the data:

Context (edges A->B with summaries):
{A_deps_text}

Additional detail (what parts of B are used by A):
{B_deps_text}

Cycle explanation (generated by another LLM):
{cycle_explanation}
"""

        return self.ask(user)