from agent_setup import AgentBase
from typing import Dict, Tuple

REFACTORING_EXPERT_PROMPT = """Your job: Give useful context about a dependency cycle, that might assist in breaking the cycle.

ATD rules:
- ANY reference counts (dynamic/lazy). Making imports lazy or dynamic is NOT sufficient as they are still static coupling.
- Ignore type-only references (anything under TYPE_CHECKING).
- We care about static coupling, not just runtime import order.
- No new cycles.

An edge A->B is fully broken when:
- There is not a single import of B from A (no top-level and no nested imports anywhere; TYPE_CHECKING-only is allowed).
- If you introduce a new file, it must not import back to the original files involved in the cycle.
- Do not partially break the edge: remove **all** imports for the chosen edge (except TYPE_CHECKING).

Do not give a refactoring plan. Just give context about the cycle. Do not assess difficulty of breaking each edge. You are only to give facts, and never to make assumptions or suggestions. When unsure, say so.
Make your context as useful as possible. Also, give some pointers as to what the reader should look for in the cycle. Give a rough guide to where in the code the most important stuff is for this cycle.
Emphasize in your output that the reader should look at the actual code to se what will work best.
"""


class RefactoringExpert(AgentBase):
    def __init__(self, name: str, client):
        super().__init__(name, client, REFACTORING_EXPERT_PROMPT)

    def propose(self, dep_summaries_A: Dict[str, Tuple[str, str]], dep_summaries_B: Dict[str, Tuple[str, str]], cycle_explanation: str) -> str:
        """
        dep_summaries: list of (A_path, B_path, dep_expert_text)
        """
        self.reset()
        A_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_A.items())]
        )
        B_deps_text = "\n\n".join(
            [f"Edge {i+1}: {a} → {b}\n{txt}"
            for i, (a, (b, txt)) in enumerate(dep_summaries_B.items())]
        )

        user = f"""Here is the data:

Context (edges A->B with summaries):
{A_deps_text}

Additional detail (what parts of B are used by A):
{B_deps_text}

Cycle explanation (generated by another LLM. Might include flaws, so be sceptical):
{cycle_explanation}
"""

        return self.ask(user)